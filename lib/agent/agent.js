/*
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 * agent.js: in-zone agent responsible for maintaining configuration files
 *
 * This agent makes extensive use of objects called configuration manifests.
 * These manifests describe all data associated with a configuration file,
 * including but not limited to its template, where that file is installed, and
 * which service is associated with the file.  These manifests are generated by
 * the Services API (SAPI) and retrieved through the local metadata API.  Since
 * the metadata API doesn't support JSON, these manifests are serialized into
 * a packed string and reconstructed by this agent.
 *
 * The full list of fields includes:
 *
 * 	name		The manifest's name.
 *
 * 	template	The file's hogan.js template.
 *
 *	contents	The rendered configuration file, basically the
 *			template + metadata.  This is not actually stored in
 *			SAPI but rather generated here in the zone.
 *
 *	path		Where this file is installed.
 *
 *	type		One of 'text' or 'json'. Used in formatting the
 *			rendered template.
 *
 *	service		(Optional) The SMF service to which this file applies.
 *			This service is refreshed when the file is updated.  If
 *			this is not provided, then no service is refreshed when
 *			the file is written.
 *
 * In addition to the configuration manfiests, each zone also has a set of
 * metadata values.  These values are used to render the configuration file from
 * the manifest's template.  These values are stored separately from the
 * manfiests since the metadata values apply to all manifests in a zone.
 *
 * See mod_manifests.unserialize() for the retrieval of both the manifests and
 * metadata.
 */

var assert = require('assert-plus');
var async = require('async');
var exec = require('child_process').exec;
var fs = require('fs');
var hogan = require('hogan.js');
var sprintf = require('util').format;
var vasync = require('vasync');

var mod_manifests = require('../common/manifests');


function Agent(config) {
	assert.object(config);
	assert.object(config.log);
	assert.object(config.mdata);

	this.log = config.log;

	/*
	 * Normally this would just be require()'d above; however, it's a
	 * configuration option to facilitate testing.  The test code provides a
	 * mdata object which doesn't actually talk to the metadata API;
	 * instead, it fabricates resposnses to test this agent.
	 */
	this.mdata = config.mdata;
}

Agent.prototype.checkAndRefresh = function checkAndRefresh(cb) {
	var self = this;
	var log = self.log;

	async.waterfall([
		function (subcb) {
			mod_manifests.unserialize.call(self, subcb);
		},
		function (manifests, metadata, subcb) {
			assert.arrayOfObject(manifests, 'manifests');
			assert.object(metadata, 'metadata');

			log.debug({
			    manifests: manifests,
			    metadata: metadata
			}, 'read manifests and metadata');

			manifests.forEach(function (manifest) {
				renderConfigFile.call(self, manifest, metadata);
			});
			return (subcb(null, manifests));
		},
		function (manifests, subcb) {
			vasync.forEachParallel({
				func: writeConfigFile.bind(self),
				inputs: manifests
			}, function (err) {
				return (subcb(err));
			});
		}
	], function (err, results) {
		if (err)
			log.error(err, 'failed to write all files');

		if (cb)
			cb();
	});
};


function refreshService(service, cb) {
	var self = this;
	var log = self.log;

	var cmd = sprintf('/usr/sbin/svcadm refresh %s', service);

	exec(cmd, function (err, stdout, stderr) {
		if (err)
			log.error(err, 'failed to refresh "%s"', service);

		return (cb(err));
	});
}


/*
 * Render a service's configuration file from its manifest.
 */
function renderConfigFile(manifest, metadata) {
	var self = this;
	var log = self.log;

	assert.object(manifest, 'manifest');
	assert.string(manifest.template, 'manifest.template');

	assert.object(metadata, 'metadata');

	log.info('rendering configuration file for service %s',
	    manifest.service);

	var contents = hogan.compile(manifest.template).render(metadata);

	if (!contents) {
		log.error('failed to render configuration file');
	} else {
		log.debug({ contents: contents },
		    'rendered configuration file');
	}

	manifest.contents = contents;

	log.debug({ contents: contents }, 'generated contents for manifest %s',
	    manifest.name);

	return (manifest);
}


function writeConfigFile(manifest, cb) {
	var self = this;
	var log = self.log;

	assert.object(manifest, 'manifest');
	assert.string(manifest.name, 'manifest.name');
	assert.string(manifest.type, 'manifest.type');
	assert.string(manifest.path, 'manifest.path');
	assert.string(manifest.contents, 'manifest.contents');

	var contents = manifest.contents;
	var existing = null;

	async.waterfall([
		function (subcb) {
			fs.readFile(manifest.path, 'ascii',
			    function (err, file) {
				if (err) {
					log.warn(err, 'failed to read file %s',
					    manifest.path);
					return (subcb(null));
				}

				existing = file;
				return (subcb(null));
			});
		},
		function (subcb) {
			if (manifest.type === 'json') {
				var obj = null;
				try {
					obj = JSON.parse(contents);
				} catch (e) {}

				if (obj)
					contents = JSON.stringify(obj, null, 4);
			}

			if (existing && contents === existing) {
				log.info('file %s unchaged; not updating ' +
				    'file nor refreshing service',
				    manifest.path);
				return (subcb(null, true));
			}

			log.info('writing %s file into %s', manifest.type,
				manifest.path);

			fs.writeFile(manifest.path, contents, function (err) {
				if (err) {
					log.error(err, 'failed to write ' +
					    'file %s', manifest.path);
					return (subcb(err));
				}

				log.info('updated file for manifest %s',
				    manifest.name);

				return (subcb(null, false));
			});

			return (null);
		},
		function (norefresh, subcb) {
			if (norefresh)
				return (subcb(null));

			if (!manifest.service) {
				log.debug('no service for manifest %s',
				    manifest.name);
				return (subcb(null));
			}

			refreshService.call(self, manifest.service, subcb);
			return (null);
		}
	], function (err) {
		if (err) {
			log.error(err, 'failed to update file for manifest %s',
			    manifest.name);
			return (cb(err));
		}

		return (cb(null));
	});
}

module.exports = Agent;
