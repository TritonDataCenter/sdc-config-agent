/*
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 * agent.js: in-zone agent responsible for maintaining configuration files
 *
 * This agent makes extensive use of objects called configuration manifests.
 * These manifests describe all data associated with a configuration file,
 * including but not limited to its template, where that file is installed, and
 * which service is associated with the file.  These manifests are generated by
 * the Services API (SAPI) and retrieved through the local metadata API.  Since
 * the metadata API doesn't support JSON, these manifests are serialized into
 * a packed string and reconstructed by this agent.
 *
 * The full list of fields includes:
 *
 * 	template	The file's hogan.js template.
 *
 *	XXX this is inaccurate
 *	md_keys		An array of metadata keys which may be used to render
 *			the contents of the configuration file.  Note that this
 *			does not contain the actual metadata, just the keys. The
 *			actual metadata is stored separately to allow consumers
 *			to update it easily without modifying these manifests.
 *
 *	md_vals		The actual metadata values.  Not stored with this
 *			manifest in SAPI -- these values are read from the
 *			metadata API as this manifest is being processed.
 *
 *	contents	The rendered configuration file, basically the
 *			template + metadata.  This is not actually stored in
 *			SAPI but rather generated here in the zone.
 *
 *	path		Where this file is installed.
 *
 *	type		One of 'text' or 'json'. Used in formatting the
 *			rendered template.
 *
 *	service		(Optional) The SMF service to which this file applies.
 *			This service is refreshed when the file is updated.  If
 *			this is not provided, then no service is refreshed when
 *			the file is written.
 */

var assert = require('assert-plus');
var async = require('async');
var exec = require('child_process').exec;
var fs = require('fs');
var hogan = require('hogan.js');
var sprintf = require('util').format;
var vasync = require('vasync');

var mod_manifest = require('./manifest');

var SENTINEL = '/opt/smartdc/config-agent/.configuration_written';

// XXX this belongs in its own file
var MDATA_KEYS = 'metadata_keys';


function Agent(config) {
	assert.object(config);
	assert.object(config.log);
	assert.object(config.mdata);

	this.log = config.log;

	/*
	 * Normally this would just be require()'d above; however, it's a
	 * configuration option to facilitate testing.  The test code provides a
	 * mdata object which doesn't actually talk to the metadata API;
	 * instead, it fabricates resposnses to test this agent.
	 */
	this.mdata = config.mdata;
}

Agent.prototype.alreadyWritten = function alreadyWritten(cb) {
	var log = this.log;

	fs.open(SENTINEL, 'r', function (err, fd) {
		if (err) {
			log.info(err, 'sentinel file doesn\'t exist');
			return (cb(null, false));
		}

		log.info('sentinel file exists');
		fs.close(fd);
		return (cb(null, true));
	});
};

function writeSentinelFile(cb) {
	var self = this;
	var log = self.log;

	fs.open(SENTINEL, 'w', function (err, fd) {
		if (err) {
			log.error(err, 'failed to create sentinel file');
			return (cb(err));
		}

		fs.close(fd);

		log.info('created sentinel file successfully');

		return (cb(null));
	});
}


Agent.prototype.checkAndRefresh = function checkAndRefresh(cb) {
	var self = this;
	var log = self.log;

	async.waterfall([
		function (subcb) {
			mod_manifest.readAll.call(self, subcb);
		},
		function (manifests, subcb) {
			log.debug({ manifests: manifests }, 'read manifests');

			readMetadata.call(self, function (err, metadata) {
				if (err)
					return (subcb(err));

				return (subcb(null, manifests, metadata));
			});
		},
		function (manifests, metadata, subcb) {
			manifests.forEach(function (manifest) {
				renderConfigFile.call(self, manifest, metadata);
			});
			return (subcb(null, manifests));
		},
		function (manifests, subcb) {
			vasync.forEachParallel({
				func: function (manifest, subsubcb) {
					writeConfigFile.call(self, manifest,
					    subsubcb);
				},
				inputs: manifests
			}, function (err, results) {
				return (subcb(err));
			});
		},
		function (subcb) {
			writeSentinelFile.call(self, subcb);
		}
	], function (err, results) {
		if (err)
			log.error(err, 'failed to write all files');

		if (cb)
			cb();
	});
};


function refreshService(service, cb) {
	var self = this;
	var log = self.log;

	var cmd = sprintf('/usr/sbin/svcadm refresh %s', service);

	exec(cmd, function (err, stdout, stderr) {
		if (err)
			log.error(err, 'failed to refresh "%s"', service);

		return (cb(err));
	});
}


/*
 * Read the metadata available to this zone.
 */
function readMetadata(cb) {
	var self = this;
	var log = self.log;

	assert.func(cb, 'cb');

	self.mdata.get.call(self, MDATA_KEYS, function (err, keys) {
		if (err) {
			log.error(err, 'list of metadata keys unavailable');
			return (cb(err));
		}

		assert.arrayOfString(keys, 'keys');

		self.mdata.getAll.call(self, keys, function (suberr, values) {
			if (suberr) {
				log.error(suberr, 'failed to get metadata');
				return (cb(err));
			}

			assert.ok(keys.length === values.length);

			var metadata = {};

			for (var ii = 0; ii < keys.length; ii++)
				metadata[keys[ii]] = values[ii];

			log.debug({ metadata: metadata }, 'read metadata');

			return (cb(null, metadata));
		});

		return (null);
	});
}


/*
 * Render a service's configuration file from its manifest.
 */
function renderConfigFile(manifest, metadata) {
	var self = this;
	var log = self.log;

	assert.object(manifest, 'manifest');
	assert.string(manifest.template, 'manifest.template');

	assert.object(metadata, 'metadata');

	log.info('rendering configuration file for service %s',
	    manifest.service);

	var contents = hogan.compile(manifest.template).render(metadata);

	if (!contents) {
		log.error('failed to render configuration file');
	} else {
		log.debug({ contents: contents },
		    'rendered configuration file');
	}

	manifest.contents = contents;

	log.debug({ contents: contents }, 'generated contents for manifest %s',
	    manifest.name);

	return (manifest);
}


function writeConfigFile(manifest, cb) {
	var self = this;
	var log = self.log;

	assert.object(manifest, 'manifest');
	assert.string(manifest.name, 'manifest.name');
	assert.string(manifest.type, 'manifest.type');
	assert.string(manifest.path, 'manifest.path');
	assert.string(manifest.contents, 'manifest.contents');

	var contents = manifest.contents;

	async.waterfall([
		function (subcb) {
			if (manifest.type === 'json') {
				var obj = null;
				try {
					obj = JSON.parse(contents);
				} catch (e) {}

				if (obj)
					contents = JSON.stringify(obj, null, 4);
			}

			log.info('writing %s file into %s', manifest.type,
				manifest.path);

			fs.writeFile(manifest.path, contents, function (err) {
				if (err) {
					log.error(err, 'failed to write ' +
					    'file %s', manifest.path);
					return (subcb(err));
				}

				return (subcb(null));
			});
		},
		function (subcb) {
			if (!manifest.service) {
				log.debug('no service for manifest %s',
				    manifest.name);
				return (subcb(null));
			}

			refreshService.call(self, manifest.service, subcb);
			return (null);
		}
	], function (err) {
		if (err) {
			log.error(err, 'failed to update file for manifest %s',
			    manifest.name);
			return (cb(err));
		}

		log.info('updated file for manifest %s', manifest.name);
		return (cb(null));
	});
}

module.exports = Agent;
